#
# Example tekton chains pipeline
#
# How to use:
#
#  1 - Provision an OCP cluster
#  2 - Create a dev namespace
#  3 - Apply this namespace inside the dev namespace. It will also install openshift pipelines
#  4 - Generate cosign secrets as described in [1]: `cosign generate-key-pair k8s://openshift-pipelines/signing-secrets`
#  5 - Configure Tekton Chains
#      `oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"transparency.enabled": "true"}}'`
#      `oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"artifacts.taskrun.storage": "oci"}}'`
#      `oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"artifacts.pipeline.storage": "oci"}}'`
#  6 - Restart the controller tekton-chains-controller in openshift-pipelines namespace
#  7 - Extract public key used by cosign to sign `oc get secret signing-secrets -n openshift-pipelines  -o yaml`
#  8 - Create quay secret
#  9 - Link secret to pipeline account `oc secrets link pipeline quay --for=pull,mount`
# 10 - Launch the hello-tomcat pipeline and enjoy the attestation and signature inside OCP internal registry
# 11 - Start hello-tomcat-publish pipeline to export the image, attestation and signature to a remote registry
# 12 - Verify the signature and attestation:
#      `cosign verify --key cosign.pub $REGISTRY/hello-tomcat:<tag>`
#      `cosign verify-attestation --key cosign.pub --type slsaprovenance $REGISTRY/hello-tomcat:<tag>`
# 13 - Verify provenance on the public rekor service with the sha256 of the image: https://search.sigstore.dev/
#
# [1] - https://docs.openshift.com/container-platform/4.13/cicd/pipelines/using-tekton-chains-for-openshift-pipelines-supply-chain-security.html#signing-secrets-in-tekton-chains_using-tekton-chains-for-openshift-pipelines-supply-chain-security
#
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-pipelines-operator
  namespace: openshift-operators
spec:
  channel:  latest
  name: openshift-pipelines-operator-rh
  source: redhat-operators
  sourceNamespace: openshift-marketplace
---
apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: jws56-openjdk11-openshift-rhel8
spec:
  lookupPolicy:
    local: true
  tags:
  - annotations:
      description: Red Hat JBoss WS 5.6 Image
    from:
      kind: DockerImage
      name: registry.redhat.io/jboss-webserver-5/jws56-openjdk11-openshift-rhel8
    name: latest
    referencePolicy:
      type: Local
---
apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: hello-tomcat
spec:
  lookupPolicy:
    local: true
---
apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: hello-tomcat-artifact
spec:
  lookupPolicy:
    local: true
---
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: hello-tomcat-artifact
  labels:
    application: hello-tomcat
spec:
  resources:
    limits:
      cpu: 1000m
      memory: 4Gi
    requests:
      cpu: 500m
      memory: 512Mi
  source:
    type: Git
    git:
      ref: master
      uri: 'https://github.com/gmagnotta/examples'
    contextDir: hello-tomcat
  strategy:
    type: Source
    sourceStrategy:
      forcePull: true
      incremental: true
      from:
        kind: ImageStreamTag
        name: 'jws56-openjdk11-openshift-rhel8:latest'
      env:
        - name: MAVEN_ARGS_APPEND
          value: ''
        - name: MAVEN_S2I_GOALS
          value: 'clean package'
  postCommit: {}
  runPolicy: Serial
  output:
    to:
      kind: ImageStreamTag
      name: 'hello-tomcat-artifact:latest'
  triggers: []
---
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: hello-tomcat
  labels:
    application: hello-tomcat
spec:
  resources: {}
  source:
    type: Dockerfile
    dockerfile: |-
      FROM jws56-openjdk11-openshift-rhel8:latest
      COPY /hello-tomcat.war /deployments/ROOT.war
    images:
    - from:
        kind: ImageStreamTag
        name: 'hello-tomcat-artifact:latest'
      paths:
      - sourcePath: '/deployments/hello-tomcat.war'
        destinationDir: '.'
  strategy:
    type: Docker
    dockerStrategy:
      from:
        kind: ImageStreamTag
        name: 'jws56-openjdk11-openshift-rhel8:latest'
  postCommit: {}
  runPolicy: Serial
  output:
    to:
      kind: ImageStreamTag
      name: 'hello-tomcat:latest'
  triggers: []
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: hello-tomcat-pipelineconfig
data:
  release-image-path: 'quay.io/gmagnotta/hello-tomcat'
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: source-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: s2i-startbuild-cli
spec:
  params:
    - name: IMAGE
      default: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
      type: string
    - name: BUILDCONFIG-NAME
      type: string
  results:
    - name: IMAGE_URL
      description: the image url
    - name: IMAGE_DIGEST
      description: the image digest
    - name: SIMPLE_DIGEST
      description: the image sha without prefix
  steps:
    - name: oc
      image: $(params.IMAGE)
      env:
        - name: HOME
          value: /tekton/home
      script: |
        #!/usr/bin/env bash

        [[ "$(workspaces.manifest-dir.bound)" == "true" ]] && cd $(workspaces.manifest-dir.path)

        [[ "$(workspaces.kubeconfig-dir.bound)" == "true" ]] && [[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]] && export KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig

        set -eu -o pipefail

        oc start-build $(params.BUILDCONFIG-NAME) --wait --follow

        #VALUE=$(oc get buildconfig $(params.BUILDCONFIG-NAME) -o jsonpath='{.status.imageChangeTriggers[0].lastTriggeredImageID}')

        IMAGE=$(oc get buildconfig $(params.BUILDCONFIG-NAME) -o jsonpath='{.spec.output.to.name}' | cut -d ':' -f 1)

        IMAGE_URL=$(oc get is $IMAGE -o jsonpath='{.status.tags[0].items[0].dockerImageReference}')

        echo -n "$(echo $IMAGE_URL | cut -d '@' -f 1)" > $(results.IMAGE_URL.path)

        echo -n "$(echo $IMAGE_URL | cut -d '@' -f 2)" > $(results.IMAGE_DIGEST.path)

        echo -n "$(echo $IMAGE_URL | cut -d '@' -f 2 | cut -d ':' -f 2)" > $(results.SIMPLE_DIGEST.path)
  workspaces:
    - name: manifest-dir
      optional: true
    - name: kubeconfig-dir
      optional: true
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: hello-tomcat
spec:
  workspaces:
    - name: source
  tasks:
    - name: fetch-source
      taskRef:
        name: git-clone
        kind: ClusterTask
      workspaces:
        - name: output
          workspace: source
      params:
        - name: url
          value: "https://github.com/gmagnotta/examples"
        - name: deleteExisting
          value: "true"
    - name: compile-artifacts
      taskRef:
        name: s2i-startbuild-cli
      runAfter:
        - fetch-source
      params:
        - name: BUILDCONFIG-NAME
          value: "hello-tomcat-artifact"
    - name: build-runtime-image
      taskRef:
        name: s2i-startbuild-cli
      runAfter:
        - compile-artifacts
      params:
        - name: BUILDCONFIG-NAME
          value: "hello-tomcat"
    - name: deploy
      taskRef:
        name: openshift-client
        kind: ClusterTask
      runAfter:
        - build-runtime-image
      workspaces:
        - name: manifest-dir
          workspace: source
      params:
        - name: SCRIPT
          value: |
            cd hello-tomcat/k8s/overlay/dev

            cat <<EOF > kustomization.yaml
            apiVersion: kustomize.config.k8s.io/v1beta1
            kind: Kustomization

            resources:
            - ../../base
            images:
            - name: hello-tomcat
              newName: $(tasks.build-runtime-image.results.IMAGE_URL)@$(tasks.build-runtime-image.results.IMAGE_DIGEST)
            EOF

            oc apply -k .
    - name: update-built-image
      taskRef:
        name: openshift-client
        kind: ClusterTask
      runAfter:
        - build-runtime-image
      params:
        - name: SCRIPT
          value: |
            set -eu -o pipefail

            oc patch configmap/hello-tomcat-pipelineconfig --type merge -p '{"data":{"dev-latest-built-image":"$(tasks.build-runtime-image.results.IMAGE_URL)"}}'

            oc patch configmap/hello-tomcat-pipelineconfig --type merge -p '{"data":{"dev-latest-built-digest":"$(tasks.build-runtime-image.results.IMAGE_DIGEST)"}}'

            oc patch configmap/hello-tomcat-pipelineconfig --type merge -p '{"data":{"dev-latest-built-simpledigest":"$(tasks.build-runtime-image.results.SIMPLE_DIGEST)"}}'
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: get-configmap-value
spec:
  params:
    - name: IMAGE
      default: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
      type: string
    - name: CONFIGMAP-NAME
      type: string
    - name: CONFIGMAP-KEY
      type: string
  results:
    - name: VALUE
      description: the value read
  steps:
    - name: oc
      image: $(params.IMAGE)
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        VALUE=$(oc get configmap $(params.CONFIGMAP-NAME) -o jsonpath='{.data.$(params.CONFIGMAP-KEY)}')

        echo -n "$VALUE" > $(results.VALUE.path)

        echo "Read value is $VALUE"
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: hello-tomcat-publish
spec:
  params:
    - name: image-tag
  workspaces:
    - name: empty
  tasks:
    - name: get-image-built
      taskRef:
        name: get-configmap-value
      params:
        - name: CONFIGMAP-NAME
          value: "hello-tomcat-pipelineconfig"
        - name: CONFIGMAP-KEY
          value: "dev-latest-built-image"
    - name: getpushpath
      taskRef:
        name: get-configmap-value
      params:
        - name: CONFIGMAP-NAME
          value: "hello-tomcat-pipelineconfig"
        - name: CONFIGMAP-KEY
          value: "release-image-path"
    - name: get-image-digest
      taskRef:
        name: get-configmap-value
      params:
        - name: CONFIGMAP-NAME
          value: "hello-tomcat-pipelineconfig"
        - name: CONFIGMAP-KEY
          value: "dev-latest-built-simpledigest"
    - name: copy-image
      taskRef:
        name: skopeo-copy
        kind: ClusterTask
      runAfter:
        - getpushpath
        - get-image-built
        - get-image-digest
      workspaces:
        - name: images-url
          workspace: empty
      params:
        - name: srcImageURL
          value: "docker://$(tasks.get-image-built.results.VALUE)@sha256:$(tasks.get-image-digest.results.VALUE)"
        - name: destImageURL
          value: "docker://$(tasks.getpushpath.results.VALUE):$(params.image-tag)"
        - name: srcTLSverify
          value: "false"
        - name: destTLSverify
          value: "false"
    - name: copy-image-att
      taskRef:
        name: skopeo-copy
        kind: ClusterTask
      runAfter:
        - getpushpath
        - get-image-built
        - get-image-digest
      workspaces:
        - name: images-url
          workspace: empty
      params:
        - name: srcImageURL
          value: "docker://$(tasks.get-image-built.results.VALUE):sha256-$(tasks.get-image-digest.results.VALUE).att"
        - name: destImageURL
          value: "docker://$(tasks.getpushpath.results.VALUE):sha256-$(tasks.get-image-digest.results.VALUE).att"
        - name: srcTLSverify
          value: "false"
        - name: destTLSverify
          value: "false"
    - name: copy-image-sig
      taskRef:
        name: skopeo-copy
        kind: ClusterTask
      runAfter:
        - getpushpath
        - get-image-built
        - get-image-digest
      workspaces:
        - name: images-url
          workspace: empty
      params:
        - name: srcImageURL
          value: "docker://$(tasks.get-image-built.results.VALUE):sha256-$(tasks.get-image-digest.results.VALUE).sig"
        - name: destImageURL
          value: "docker://$(tasks.getpushpath.results.VALUE):sha256-$(tasks.get-image-digest.results.VALUE).sig"
        - name: srcTLSverify
          value: "false"
        - name: destTLSverify
          value: "false"

