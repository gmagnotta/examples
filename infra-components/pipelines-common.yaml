apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildah-s2i
spec:
  params:
    - name: BUILDAH_IMAGE
      default: registry.access.redhat.com/ubi8/buildah:8.5-14
      description: The location of the buildah builder image.
      type: string
    - name: S2I_IMAGE
      default: registry.access.redhat.com/ubi8/openjdk-11
      description: The S2I builder image.
      type: string
    - name: IMAGE
      description: Reference of the image buildah will produce.
      type: string
    - name: CONTEXT
      default: .
      description: Path to the directory to use as context.
      type: string
    - name: PUSH_EXTRA_ARGS
      default: ''
      description: Extra parameters passed for the push command when pushing images.
      type: string
    - name: TLSVERIFY
      default: 'true'
      description: >-
        Verify the TLS on the registry endpoint (for push/pull to a non-TLS
        registry)
      type: string
    - name: INCREMENTAL
      type: string
      default: "false"
    - name: USER
      type: string
      default: "jboss"
    - name: S2I_SCRIPTS_URL
      type: string
      default: "/usr/local/s2i"
  results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
  workspaces:
    - name: source
    - name: artifacts
    - name: varlibcontainers
      mountPath: /var/lib/containers
    - name: s2ienv
  steps:
    - name: build
      image: $(params.BUILDAH_IMAGE)
      env:
        - name: INCREMENTAL
          value: $(params.INCREMENTAL)
        - name: BUILDER_IMAGE
          value: $(params.S2I_IMAGE)
        - name: ASSEMBLE_USER
          value: $(params.USER)
        - name: CONTEXT_DIR
          value: $(params.CONTEXT)
        - name: SCRIPTS_URL
          value: $(params.S2I_SCRIPTS_URL)
        - name: OUTPUT_IMAGE
          value: $(params.IMAGE)
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        echo "Start"
        builder=$(buildah from --tls-verify=$(params.TLSVERIFY) $BUILDER_IMAGE)

        buildah add --chown $ASSEMBLE_USER:0 $builder $(workspaces.source.path)/$CONTEXT_DIR /tmp/src

        if [ "$INCREMENTAL" = "true" ]; then

          if [ -f "$(workspaces.artifacts.path)/artifacts.tar" ]; then
           echo "Restoring artifacts"
           buildah add --chown $ASSEMBLE_USER:0 $builder $(workspaces.artifacts.path)/artifacts.tar /tmp/artifacts
          fi

        fi

        ENV=""
        if [ -f "$(workspaces.source.path)/$CONTEXT_DIR/.s2i/environment" ]; then

            while IFS="" read -r line
            do
              [[ "$line" =~ ^#.*$ ]] && continue
              ENV+="-e $line "
            done < $(workspaces.source.path)/$CONTEXT_DIR/.s2i/environment

            echo "ENV is $ENV"

        fi

        if [ -f "$(workspaces.s2ienv.path)/environment" ]; then

            while IFS="" read -r line
            do
              [[ "$line" =~ ^#.*$ ]] && continue
              ENV+="-e $line "
            done < $(workspaces.s2ienv.path)/environment

            echo "ENV is $ENV"

        fi

        buildah config --cmd $SCRIPTS_URL/run $builder

        if [ -x "$(workspaces.source.path)/$CONTEXT_DIR/.s2i/bin/assemble" ]; then
          echo "Using assemble from .s2i"
          eval buildah run $ENV $builder -- /tmp/src/.s2i/bin/assemble
        else
          echo "Using assemble from image"
          eval buildah run $ENV $builder -- $SCRIPTS_URL/assemble
        fi

        if [ "$INCREMENTAL" = "true" ]; then

          echo "saving artifacts"
          if [ -f "$(workspaces.artifacts.path)/artifacts.tar" ]; then
            rm $(workspaces.artifacts.path)/artifacts.tar
          fi

          buildah run $builder -- /bin/bash -c "if [ -x \"$SCRIPTS_URL/save-artifacts\" ]; then $SCRIPTS_URL/save-artifacts ; fi" > $(workspaces.artifacts.path)/artifacts.tar

        fi

        buildah commit $builder $OUTPUT_IMAGE

        buildah rm $builder
      securityContext:
        capabilities:
          add:
            - SETFCAP
    - name: push
      image: $(params.BUILDAH_IMAGE)
      script: |
        buildah push \
          $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
          --digestfile $(results.IMAGE_DIGEST.path) $(params.IMAGE) \
          docker://$(params.IMAGE)

          cat $(results.IMAGE_DIGEST.path)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: image-from-dockerfile
spec:
  params:
    - description: Reference of the image buildah will produce.
      name: IMAGE
      type: string
    - default: registry.access.redhat.com/ubi8/buildah:8.5-4
      description: The location of the buildah builder image.
      name: BUILDER_IMAGE
      type: string
    - default: overlay
      description: Set buildah storage driver
      name: STORAGE_DRIVER
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: DOCKERFILE
      type: string
    - default: .
      description: Path to the directory to use as context.
      name: CONTEXT
      type: string
    - default: 'true'
      description: >-
        Verify the TLS on the registry endpoint (for push/pull to a non-TLS
        registry)
      name: TLSVERIFY
      type: string
    - default: oci
      description: 'The format of the built container, oci or docker'
      name: FORMAT
      type: string
    - default: ''
      description: Extra parameters passed for the build command when building images.
      name: BUILD_EXTRA_ARGS
      type: string
    - default: ''
      description: Extra parameters passed for the push command when pushing images.
      name: PUSH_EXTRA_ARGS
      type: string
  results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
  workspaces:
    - name: source
    - name: varlibcontainers
      mountPath: /var/lib/containers
  steps:
    - image: $(params.BUILDER_IMAGE)
      name: build
      script: |
        buildah --storage-driver=$(params.STORAGE_DRIVER) bud \
          $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \
          --tls-verify=$(params.TLSVERIFY) --no-cache \
          -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)
      securityContext:
        privileged: true
      workingDir: $(workspaces.source.path)
    - image: $(params.BUILDER_IMAGE)
      name: push
      script: |
        buildah --storage-driver=$(params.STORAGE_DRIVER) push \
          $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
          --digestfile $(results.IMAGE_DIGEST.path) $(params.IMAGE) \
          docker://$(params.IMAGE)
        
        cat $(results.IMAGE_DIGEST.path)
      securityContext:
        privileged: true
      workingDir: $(workspaces.source.path)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: get-configmap-value
spec:
  params:
    - name: IMAGE
      default: registry.redhat.io/openshift4/ose-cli
      type: string
    - name: CONFIGMAP-NAME
      type: string
    - name: CONFIGMAP-KEY
      type: string
  results:
    - name: VALUE
      description: the value read
  steps:
    - name: oc
      image: $(params.IMAGE)
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        VALUE=$(oc get configmap $(params.CONFIGMAP-NAME) -o jsonpath='{.data.$(params.CONFIGMAP-KEY)}')

        echo -n "$VALUE" > $(results.VALUE.path)

        echo "Read value is $VALUE"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: set-configmap-value
spec:
  params:
    - name: IMAGE
      default: registry.redhat.io/openshift4/ose-cli
      type: string
    - name: CONFIGMAP-NAME
      type: string
    - name: CONFIGMAP-KEY
      type: string
    - name: VALUE
      type: string
  steps:
    - name: oc
      image: $(params.IMAGE)
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        oc patch configmap/$(params.CONFIGMAP-NAME) --type merge -p '{"data":{"$(params.CONFIGMAP-KEY)":"$(params.VALUE)"}}'
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: openshift-actions
spec:
  description: >-
    This task runs oc client
  workspaces:
    - name: source
  params:
    - name: CONTEXT
      type: string
      default: .
    - name: SCRIPT
      description: The oc CLI script to run
      type: string
      default: "oc help"
    - name: IMAGE
      default: registry.redhat.io/openshift4/ose-cli
      description: Oc image
  steps:
    - name: oc
      image: $(params.IMAGE)
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        $(params.SCRIPT)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-clone
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks in
    your Pipeline.

    The git-clone Task will clone a repo from the provided url into the output
    Workspace. By default the repo will be cloned into the root of your
    Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param.
  params:
    - description: git url to clone
      name: url
      type: string
    - default: ''
      description: 'git revision to checkout (branch, tag, sha, refâ€¦)'
      name: revision
      type: string
    - default: ''
      description: (optional) git refspec to fetch before checking out revision
      name: refspec
      type: string
    - default: 'true'
      description: defines if the resource should initialize and fetch the submodules
      name: submodules
      type: string
    - default: '1'
      description: >-
        performs a shallow clone where only the most recent commit(s) will be
        fetched
      name: depth
      type: string
    - default: 'true'
      description: >-
        defines if http.sslVerify should be set to true or false in the global
        git config
      name: sslVerify
      type: string
    - default: ''
      description: subdirectory inside the "output" workspace to clone the git repo into
      name: subdirectory
      type: string
    - default: 'true'
      description: >-
        clean out the contents of the repo's destination directory (if it
        already exists) before trying to clone the repo there
      name: deleteExisting
      type: string
    - default: ''
      description: git HTTP proxy server for non-SSL requests
      name: httpProxy
      type: string
    - default: ''
      description: git HTTPS proxy server for SSL requests
      name: httpsProxy
      type: string
    - default: ''
      description: git no proxy - opt out of proxying HTTP/HTTPS requests
      name: noProxy
      type: string
    - default: 'true'
      description: log the commands used during execution
      name: verbose
      type: string
  results:
    - description: The precise commit SHA that was fetched by this Task
      name: commit
    - description: The precise URL that was fetched by this Task
      name: url
  steps:
    - image: >-
        registry.redhat.io/openshift-pipelines/pipelines-git-init-rhel8:v1.6.1-4
      name: clone
      resources: {}
      script: >
        #!/bin/sh

        set -eu -o pipefail


        if [[ "$(params.verbose)" == "true" ]] ; then
          set -x
        fi


        CHECKOUT_DIR="$(workspaces.output.path)/$(params.subdirectory)"


        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }


        if [[ "$(params.deleteExisting)" == "true" ]] ; then
          cleandir
        fi


        test -z "$(params.httpProxy)" || export HTTP_PROXY=$(params.httpProxy)

        test -z "$(params.httpsProxy)" || export
        HTTPS_PROXY=$(params.httpsProxy)

        test -z "$(params.noProxy)" || export NO_PROXY=$(params.noProxy)


        /ko-app/git-init \
          -url "$(params.url)" \
          -revision "$(params.revision)" \
          -refspec "$(params.refspec)" \
          -path "$CHECKOUT_DIR" \
          -sslVerify="$(params.sslVerify)" \
          -submodules="$(params.submodules)" \
          -depth "$(params.depth)"
        cd "$CHECKOUT_DIR"

        RESULT_SHA="$(git rev-parse HEAD)"

        EXIT_CODE="$?"

        if [ "$EXIT_CODE" != 0 ] ; then
          exit $EXIT_CODE
        fi

        # ensure we don't add a trailing newline to the result

        echo -n "$RESULT_SHA" > $(results.commit.path)

        echo -n "$(params.url)" > $(results.url.path)
  workspaces:
    - description: The git repo will be cloned onto the volume backing this workspace
      name: output
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: clean-pvs
spec:
  workspaces:
    - name: artifacts
    - name: varlibcontainers
      mountPath: /var/lib/containers
  steps:
    - name: clean
      image: registry.access.redhat.com/ubi8/buildah:8.5-14
      script: |
        #!/usr/bin/env bash
        set -eu -o pipefail

        if [ -f "$(workspaces.artifacts.path)/artifacts.tar" ]; then
          echo "Deleting artifacts.tar"
          rm -rf $(workspaces.artifacts.path)/artifacts.tar
        fi

        echo "Cleaning container image cache"
        buildah rmi --all
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: s2i-startbuild-cli
spec:
  params:
    - name: IMAGE
      default: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
      type: string
    - name: BUILDCONFIG-NAME
      type: string
  results:
    - name: VALUE
      description: the value read
    - name: URL
      description: the image url
    - name: DIGEST
      description: the image digest
  steps:
    - name: oc
      image: $(params.IMAGE)
      env:
        - name: HOME
          value: /tekton/home
      script: |
        #!/usr/bin/env bash

        [[ "$(workspaces.manifest-dir.bound)" == "true" ]] && cd $(workspaces.manifest-dir.path)

        [[ "$(workspaces.kubeconfig-dir.bound)" == "true" ]] && [[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]] && export KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig

        set -eu -o pipefail
        
        oc start-build $(params.BUILDCONFIG-NAME) --wait --follow

        #VALUE=$(oc get buildconfig $(params.BUILDCONFIG-NAME) -o jsonpath='{.status.imageChangeTriggers[0].lastTriggeredImageID}')

        IMAGE=$(oc get buildconfig $(params.BUILDCONFIG-NAME) -o jsonpath='{.spec.output.to.name}' | cut -d ':' -f 1)

        VALUE=$(oc get is $IMAGE -o jsonpath='{.status.tags[0].items[0].dockerImageReference}')

        echo -n "$VALUE" > $(results.VALUE.path)

        echo "Built image is $VALUE"

        URL=$(echo $VALUE | cut -d '@' -f 1)

        echo -n "$URL" > $(results.URL.path)

        echo "URL is $URL"

        DIGEST=$(echo $VALUE | cut -d '@' -f 2 | cut -d ':' -f 2)

        echo -n "$DIGEST" > $(results.DIGEST.path)

        echo "Digest is $DIGEST"
  workspaces:
    - name: manifest-dir
      optional: true
    - name: kubeconfig-dir
      optional: true
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: scan-code
spec:
  params:
    - default: 'docker.io/sonarsource/sonar-scanner-cli:latest'
      name: scanImage
      type: string
    - default: 'https://sonarqube-sonarqube.apps.cluster-tpn6s.sandbox2653.opentlc.com/'
      name: sonarqubeHostUrl
      type: string
    - default: object-detection-rest
      name: sonarqubeProjectKey
      type: string
    - default: object-detection-rest-sonarqube-secret
      name: sonarqubeProjectSecret
      type: string
    - default: object-detection-rest-sonarqube-secret
      name: sonarqubeProjectSecretKey
      type: string
    - default: 'true'
      name: verbose
      type: string
    - default: './'
      name: path
      type: string
  steps:
    - env:
        - name: SONAR_TOKEN_WEB_UI
          valueFrom:
            secretKeyRef:
              key: $(params.sonarqubeProjectSecretKey)
              name: $(params.sonarqubeProjectSecret)
      image: $(params.scanImage)
      name: scan-code
      resources: {}
      script: >
        set -x

        echo $(ls -a)

        sonar-scanner -X -Dsonar.projectKey=$(params.sonarqubeProjectKey)
        -Dsonar.sources=$(params.path) -Dsonar.host.url=$(params.sonarqubeHostUrl)
        -Dsonar.login=$SONAR_TOKEN_WEB_UI
      workingDir: /workspace/repository
  workspaces:
    - name: repository
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: cosign
spec:
  params:
    - default: 'gcr.io/projectsigstore/cosign'
      name: IMAGE
      type: string
    - default: 'empty'
      name: IMAGETOSIGN
      type: string
    - default: 'cosign-key'
      name: COSIGNKEY
      type: string
  steps:
    - image: $(params.IMAGE)
      name: sign-container
      resources: {}
      args:
        - sign
        - --key
        - $(params.COSIGNKEY)
        - $(params.IMAGETOSIGN)
        - -y
        - --upload=true
      workingDir: /workspace/repository